# Relationship Design

As we change to a more distributed object model, the idea of a direct relationship via a teamId or ownerId becomes harder to maintain on every object. It also makes it hard to expand the layers that could potentially relate to an object (hierarchy) but also hard to query for a mapping.

## Model 1

In the first iteration we implemented a model where every object got a relationship to the User, Team, Workflow, or whatever parent.

The problem we faced was that the model didn't handle slugs (which weren't present in the solution when we built this model) and it meant that an objects ID may be in many documents which causes an update issue. Making updates was hard.

```json
{
    "_id" : "<generated>",
    "fromType" : "TEAM",
    "fromRef" : "66b00d0fcee32a300dc0a3ee",
    "label" : "OWNER",
    "toType" : "ORGANISATION",
    "toRef" : "66b00d0fcee32a300dc0a3ee",
}
```

## Model 2

As we expanded on this concept and looked into Gremlin / Mongo graph relationships using vertex and edge.

Problem was constantly going across collections to get the nodes and the edges creating an expensive query problem.

### Vertex (Node)

A node describes a data entity.

A typical data structure would create the following, however it is entirely flexible and can be of any type of entity. We could utilise the current objects such as Team and User, however we don't have matching data structures for Global or System.

```json
{
  "_id": "<generated>",
  "orgRef": "Organization for the vertex",
  "vertexRef": "123",
  "label": "organization|team|user|global|system|workflow|task|token?",
  "attributes": {
    "key": "value"
  }
}
```

| Element      | Description or Mapping                                                                                                                                       |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `_id`        | Generated by MongoDB                                                                                                                                         |
| `orgRef`     | Technically we could use a Node for the Organisation but we would have to traverse the Graph for all objects in that Organisation. _Potentially remove this_ |
| `vertexRef`  | The link to the MongoDB related object                                                                                                                       |
| `label`      | The type of the Node / Vertex                                                                                                                                |
| `attributes` | Additional data that is needed to be stored                                                                                                                  |

### Edge (Relationship)

An edge stores the relationship between two vertex (or nodes). An edge has a from and to node and describes the type of relationship between the entities.

Data structure for edge:

```json
{
  "_id": "<generated>",
  "orgRef": "Organization for the vertex",
  "fromRef": "1231241412",
  "toRef": "124124214124212",
  "label": "member-of|belongs-to|has-member",
  "attributes": {
    "key": "Value"
  }
}
```

## Model 3

With this model, the object holds the connections (or edges) from itself to another object. I.e. WorkflowRun has a relationship to a TEAM and the to of the connection is to the other relationship object. 

The `data` object holds additional information such as Display Name or other fields so as not have to do another full MongoDB query.

The benefit of this model are;
- keeping the ID between the relationship nodes rather than to the objects which may change.
- If you delete the node, the relationships are automatically removed

```json
{
    "_id" : "<generated>",
    "type" : "TEAM",
    "ref" : "66b00d0fcee32a300dc0a3ee",
    "slug" : "scorecard",
    "data" : {},
    "connections" : [
    {
        "label" : "BELONGSTO",
        "to" : ObjectId("66062121178f8a388abaef53"),
        "data" : {}
    }
    ],
}
```

## Model 4

Along the way we have introduced new concepts (like slugs) and learnt what we are trying to achieve with the Relationship model when storing it in a document based database.

**Aim:**
- Allow for lookup by slug (end user requests come with slug not ID)
  - This is essentially an $or in MongoDB
- Remove propogation of IDs (find a way to not have the same ID everywhere within the relationship collection)
- No embedding relationships using 'connections', use an aggregate call to retrieve
- Limit going across collections, as much as possible.

**Solution**
In coming up with the solution, I went back to checking OSO, SpiceDB (AuthZed), Gremlin, Microsoft, etc, and also ran multiple scenarios through GitHub Copilot for reference material and comparing the pros and cons.

The summary is, that we should use the Nodes (Vertices), and Edges storage of relationships in MongoDB, however the constant read is a concern with the MongoDB Graph Aggregate across connections. I don't have exact reference material on the cost, but I expect if we did a view inside CosmosDB or Atlas, the costs would add up.

The answer to this, is to generate an in memory Relationship Graph using JGraphT (which we already using inside the Engine for the DAG), although this time we use the BFSShortestPath as an unweighted way of determining the path between nodes.

This also solves the issue where we kept having to do Graph Aggregates to get multiple layers of the graph, for example from User -> Team / Workspace -> Component. By generating a graph we can determine if there is a path from User -> Component.

The in memory implementation, does mean that we need to rebuild the graph every time there is an update to the nodes or edges. However considering the majority is checking relationships and not creating / updating / deleting, this caches the reads as much as possible. We do not a lock collection, or event, to be created where by we can say 'rebuild the graph' as an external prompt to ensure scaling of service's doesn't break the graph.

## Reference

- [Getting Started with Graph Databases: Azure CosmosDB with Gremlin API](https://itnext.io/getting-started-with-graph-databases-azure-cosmosdb-with-gremlin-api-and-python-80e57cbd1c5e)
- [MongoDB Graph Database](https://www.mongodb.com/databases/mongodb-graph-database)
- [MongoDB graphLookup](https://www.mongodb.com/docs/v4.4/reference/operator/aggregation/graphLookup/)
- [Spring Data Gremlin](https://github.com/gjrwebber/spring-data-gremlin)
- [OSOHQ ReBAC](https://www.osohq.com/academy/relationship-based-access-control-rebac)
- [AuthZed Permissions System]https://authzed.com/blog/permissions-systems-building-an-authorization-lexicon
